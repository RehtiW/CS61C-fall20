### 块(Block):
计算机的内存通常是以**块**为单位进行管理的，每个数据块包含多个字节。
ByteOffset位数取决于:logN(N = 块所包含字节数)
Index位数取决于:logN(N = 缓存行数)
N = 缓存可以存储的字节总量/(Bytes/Block)
Tag位数取决于: 32 - B - I
![[Pasted image 20241224175916.png]]
### 直接映射法的工作原理

1. **读取数据时**：
    
    - CPU发出一个内存访问请求，给出一个内存地址。
    - 地址被分为：**标签（Tag）**，**索引（Index）**和块偏移（Block Offset）**。
    - 使用**索引部分选择缓存中的某一行**（即缓存行）。
    - 然后，检查缓存行的**有效位（valid bit)**,若为**0,则强制性未命中**,若为1,则检查**缓存行中的标签(Tag)部分**，如果标签部分与内存地址的标签部分匹配,说明缓存命中（cache hit），可以直接从缓存中读取数据。 
    - **-----为什么要先检查有效位,若有效位为0,tag位可能存储垃圾**
    - 如果标签不匹配或缓存行无效，说明缓存未命中（cache miss），需要从主内存加载数据到缓存，再从缓存中读取数据。
2. **写入数据时**：
		**写回（Write-Back）** 和 **写直达（Write-Through）**。
#### 1. **写直达（Write-Through）**：

- **写入操作**会同时更新缓存和主存中的数据。
- 每当CPU需要将数据写入缓存时，不仅更新缓存中的数据，还会立即将相同的数据写入主存。
- **优点**：保证了缓存和主存的一致性，因为主存中的数据总是保持最新的。
- **缺点**：写操作会频繁访问主存，可能导致性能瓶颈，尤其是在写操作频繁的程序中。

#### 2. **写回（Write-Back）**：
- 只有当缓存行中的数据被替换（即缓存行被驱逐或清除,操作系统刷新缓存）时，才将修改后的数据写回主存。
- **优点**：减少了对主存的写访问，能够显著提高性能，特别是在写操作频繁的应用中。
- **缺点**：可能导致主存和缓存的数据不一致，因此需要额外的机制（例如**写回标志**）来确保缓存与主存的一致性。
	    ![[Pasted image 20241226211227.png]]
    
图示是一个接近真实的缓存,存储16KB,每个块大小位16B,10位Index,4位offset
![[Pasted image 20241224180119.png]]
    

### 直接映射法的优缺点

#### 优点：

1. **实现简单**：直接映射法的硬件实现非常简单，因为只需要使用地址的索引部分来选择缓存中的行，并且直接与标签进行比较。
2. **访问速度快**：由于只需要比较标签和索引，缓存访问速度较快。

#### 缺点：

1. **冲突较多**：多个内存块可能会映射到同一个缓存行中，这会导致**缓存冲突**。例如，如果两个不同的内存块的索引部分相同，它们将被映射到同一缓存行，导致频繁的替换和缓存未命中。
2. **缓存利用率低**：由于缓存行之间没有灵活的映射机制，可能导致缓存空间无法充分利用。

![[Pasted image 20241224191347.png]]

## 块大小对性能的影响
![[Pasted image 20241226212326.png]]